{"version":3,"sources":["lib/formatter.js"],"names":["global","factory","exports","module","define","amd","self","jsonlintFormatter","this","repeat","s","count","Array","join","format","json","indentChars","i","il","tab","newJson","indentLevel","inString","currentChar","length","charAt","Object","defineProperty","value"],"mappings":"CAAC,SAAUA,OAAQC,gBAEVC,UAAY,iBAAmBC,SAAW,YAAcF,QAAQC,gBAE5DE,SAAW,YAAcA,OAAOC,IAAMD,OAAO,qBAAsB,CAAC,WAAYH,UAEpFD,OAASA,QAAUM,KAAML,QAAQD,OAAOO,kBAAoB,MANrE,CAOEC,KAAM,SAAUN,SAChB,aAUA,SAASO,OAAQC,EAAGC,OAClB,OAAO,IAAIC,MAAMD,MAAQ,GAAGE,KAAKH,GAGnC,SAASI,OAAQC,KAAMC,aACrB,IAAIC,EAAI,EACR,IAAIC,GAAK,EACT,IAAIC,WAAcH,cAAgB,YAAeA,YAAc,OAC/D,IAAII,QAAU,GACd,IAAIC,YAAc,EAClB,IAAIC,SAAW,MACf,IAAIC,YAAc,KAElB,IAAKN,EAAI,EAAGC,GAAKH,KAAKS,OAAQP,EAAIC,GAAID,GAAK,EAAG,CAC5CM,YAAcR,KAAKU,OAAOR,GAC1B,OAAQM,aACN,IAAK,IACL,IAAK,IACH,IAAKD,SAAU,CACbF,SAAWG,YAAc,KAAOd,OAAOU,IAAKE,YAAc,GAC1DA,aAAe,MACV,CACLD,SAAWG,YAEb,MACF,IAAK,IACL,IAAK,IACH,IAAKD,SAAU,CACbD,aAAe,EACfD,SAAW,KAAOX,OAAOU,IAAKE,aAAeE,gBACxC,CACLH,SAAWG,YAEb,MACF,IAAK,IACH,IAAKD,SAAU,CACbF,SAAW,MAAQX,OAAOU,IAAKE,iBAC1B,CACLD,SAAWG,YAEb,MACF,IAAK,IACH,IAAKD,SAAU,CACbF,SAAW,SACN,CACLA,SAAWG,YAEb,MACF,IAAK,IACL,IAAK,KACL,IAAK,KACH,GAAID,SAAU,CACZF,SAAWG,YAEb,MACF,IAAK,IACH,GAAIN,EAAI,GAAKF,KAAKU,OAAOR,EAAI,KAAO,KAAM,CACxCK,UAAYA,SAEdF,SAAWG,YACX,MACF,QACEH,SAAWG,YACX,OAIN,OAAOH,QAGTlB,QAAQY,OAASA,OAEjBY,OAAOC,eAAezB,QAAS,aAAc,CAAE0B,MAAO","file":"formatter.js","sourcesContent":["(function (global, factory) {\n  // eslint-disable-next-line no-unused-expressions\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)\n  // eslint-disable-next-line no-undef\n    : typeof define === 'function' && define.amd ? define('jsonlint-formatter', ['exports'], factory)\n    // eslint-disable-next-line no-undef\n      : (global = global || self, factory(global.jsonlintFormatter = {}))\n}(this, function (exports) {\n  'use strict'\n\n  /**\n   * Manual formatter taken straight from https://github.com/umbrae/jsonlintdotcom\n   *\n   * jsl.format - Provide json reformatting in a character-by-character approach,\n   *   so that even invalid JSON may be reformatted (to the best of its ability).\n   *\n   */\n\n  function repeat (s, count) {\n    return new Array(count + 1).join(s)\n  }\n\n  function format (json, indentChars) {\n    var i = 0\n    var il = 0\n    var tab = (typeof indentChars !== 'undefined') ? indentChars : '    '\n    var newJson = ''\n    var indentLevel = 0\n    var inString = false\n    var currentChar = null\n\n    for (i = 0, il = json.length; i < il; i += 1) {\n      currentChar = json.charAt(i)\n      switch (currentChar) {\n        case '{':\n        case '[':\n          if (!inString) {\n            newJson += currentChar + '\\n' + repeat(tab, indentLevel + 1)\n            indentLevel += 1\n          } else {\n            newJson += currentChar\n          }\n          break\n        case '}':\n        case ']':\n          if (!inString) {\n            indentLevel -= 1\n            newJson += '\\n' + repeat(tab, indentLevel) + currentChar\n          } else {\n            newJson += currentChar\n          }\n          break\n        case ',':\n          if (!inString) {\n            newJson += ',\\n' + repeat(tab, indentLevel)\n          } else {\n            newJson += currentChar\n          }\n          break\n        case ':':\n          if (!inString) {\n            newJson += ': '\n          } else {\n            newJson += currentChar\n          }\n          break\n        case ' ':\n        case '\\n':\n        case '\\t':\n          if (inString) {\n            newJson += currentChar\n          }\n          break\n        case '\"':\n          if (i > 0 && json.charAt(i - 1) !== '\\\\') {\n            inString = !inString\n          }\n          newJson += currentChar\n          break\n        default:\n          newJson += currentChar\n          break\n      }\n    }\n\n    return newJson\n  }\n\n  exports.format = format\n\n  Object.defineProperty(exports, '__esModule', { value: true })\n}))\n"]}