{"version":3,"sources":["lib/jsonlint.js"],"names":["global","factory","exports","module","define","amd","self","jsonlint","this","o","k","v","l","length","$V0","$V1","$V2","$V3","$V4","$V5","$V6","$V7","$V8","$V9","$Va","$Vb","parser","trace","yy","symbols_","error","JSONString","STRING","SINGLEQUOTED_STRING","JSONNumber","NUMBER","JSONNullLiteral","NULL","JSONBooleanLiteral","TRUE","FALSE","JSONText","JSONValue","EOF","JSONObject","JSONArray","{","}","JSONMemberList","JSONMember",":",",","[","]","JSONElementList","$accept","$end","terminals_","2","4","5","7","9","11","12","15","18","19","22","23","24","25","productions_","performAction","anonymous","yytext","yyleng","yylineno","yystate","$$","_$","$0","$","replace","Number","push","table","3","6","8","10","13","14","16","17","1","20","21","26","defaultActions","parseError","str","hash","recoverable","Error","parse","input","stack","tstack","vstack","lstack","recovering","TERROR","args","slice","call","arguments","lexer","Object","create","sharedState","prototype","hasOwnProperty","setInput","yylloc","yyloc","ranges","options","getPrototypeOf","popStack","n","_token_stack","lex","token","symbol","preErrorSymbol","state","action","a","r","yyval","p","len","newState","expected","errStr","showPosition","join","text","match","line","loc","Array","first_line","last_line","first_column","last_column","range","apply","concat","_input","_more","_backtrack","done","matched","conditionStack","offset","ch","lines","unput","split","substr","oldLines","more","reject","backtrack_lexer","less","pastInput","past","upcomingInput","next","pre","c","test_match","indexed_rule","backup","matches","tempMatch","index","rules","_currentRules","i","flex","begin","condition","popState","pop","conditions","topState","Math","abs","pushState","stateStackSize","yy_","$avoiding_name_collisions","YY_START","fail","reason","message","string","comment","ignoreComments","singleQuotedString","allowSingleQuotedStrings","YYSTATE","INITIAL","inclusive","Parser","getLineAndColumn","column","start","max","previous","rest","min","getPositionContext","upcoming","pointer","exzerpt","getReason","firstCharacter","charAt","toUpperCase","getLocationOnV8","exec","location","checkUnexpectedEndOnV8","getLocationOnSpiderMonkey","getOffset","getTexts","position","improveNativeError","texts","parseNatively","JSON","needsCustomParser","limitedErrorInfo","breaks","improveCustomError","parseCustom","ConfigurableParser","constructor","processOptions","changed","restoreContext","undefined","option","value","bind","defineProperty"],"mappings":"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","file":"jsonlint.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('jsonlint', ['exports'], factory) :\n  (global = global || self, factory(global.jsonlint = {}));\n}(this, function (exports) { 'use strict';\n\n/* parser generated by jison 0.4.18 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar jsonlint = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,12],$V1=[1,13],$V2=[1,14],$V3=[1,9],$V4=[1,10],$V5=[1,11],$V6=[1,15],$V7=[1,16],$V8=[15,19,23,25],$V9=[15,19,22,23,25],$Va=[19,23],$Vb=[23,25];\nvar parser = {trace: function trace () { },\nyy: {},\nsymbols_: {\"error\":2,\"JSONString\":3,\"STRING\":4,\"SINGLEQUOTED_STRING\":5,\"JSONNumber\":6,\"NUMBER\":7,\"JSONNullLiteral\":8,\"NULL\":9,\"JSONBooleanLiteral\":10,\"TRUE\":11,\"FALSE\":12,\"JSONText\":13,\"JSONValue\":14,\"EOF\":15,\"JSONObject\":16,\"JSONArray\":17,\"{\":18,\"}\":19,\"JSONMemberList\":20,\"JSONMember\":21,\":\":22,\",\":23,\"[\":24,\"]\":25,\"JSONElementList\":26,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",4:\"STRING\",5:\"SINGLEQUOTED_STRING\",7:\"NUMBER\",9:\"NULL\",11:\"TRUE\",12:\"FALSE\",15:\"EOF\",18:\"{\",19:\"}\",22:\":\",23:\",\",24:\"[\",25:\"]\"},\nproductions_: [0,[3,1],[3,1],[6,1],[8,1],[10,1],[10,1],[13,2],[14,1],[14,1],[14,1],[14,1],[14,1],[14,1],[16,2],[16,3],[21,3],[20,1],[20,3],[17,2],[17,3],[26,1],[26,3]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\n // replace escaped characters with actual character\n          this.$ = yytext.replace(/\\\\(\\\\|\")/g, \"$\"+\"1\")\n                     .replace(/\\\\n/g,'\\n')\n                     .replace(/\\\\r/g,'\\r')\n                     .replace(/\\\\t/g,'\\t')\n                     .replace(/\\\\v/g,'\\v')\n                     .replace(/\\\\f/g,'\\f')\n                     .replace(/\\\\b/g,'\\b');\n        \nbreak;\ncase 2:\n // replace escaped characters with actual character\n          this.$ = yytext.replace(/\\\\(\\\\|')/g, \"$\"+\"1\")\n                     .replace(/\\\\n/g,'\\n')\n                     .replace(/\\\\r/g,'\\r')\n                     .replace(/\\\\t/g,'\\t')\n                     .replace(/\\\\v/g,'\\v')\n                     .replace(/\\\\f/g,'\\f')\n                     .replace(/\\\\b/g,'\\b');\n        \nbreak;\ncase 3:\nthis.$ = Number(yytext);\nbreak;\ncase 4:\nthis.$ = null;\nbreak;\ncase 5:\nthis.$ = true;\nbreak;\ncase 6:\nthis.$ = false;\nbreak;\ncase 7:\nreturn this.$ = $$[$0-1];\nbreak;\ncase 14:\nthis.$ = {};\nbreak;\ncase 15: case 20:\nthis.$ = $$[$0-1];\nbreak;\ncase 16:\nthis.$ = [$$[$0-2], $$[$0]];\nbreak;\ncase 17:\nthis.$ = {}; this.$[$$[$0][0]] = $$[$0][1];\nbreak;\ncase 18:\nthis.$ = $$[$0-2]; $$[$0-2][$$[$0][0]] = $$[$0][1];\nbreak;\ncase 19:\nthis.$ = [];\nbreak;\ncase 21:\nthis.$ = [$$[$0]];\nbreak;\ncase 22:\nthis.$ = $$[$0-2]; $$[$0-2].push($$[$0]);\nbreak;\n}\n},\ntable: [{3:5,4:$V0,5:$V1,6:6,7:$V2,8:3,9:$V3,10:4,11:$V4,12:$V5,13:1,14:2,16:7,17:8,18:$V6,24:$V7},{1:[3]},{15:[1,17]},o($V8,[2,8]),o($V8,[2,9]),o($V8,[2,10]),o($V8,[2,11]),o($V8,[2,12]),o($V8,[2,13]),o($V8,[2,4]),o($V8,[2,5]),o($V8,[2,6]),o($V9,[2,1]),o($V9,[2,2]),o($V8,[2,3]),{3:21,4:$V0,5:$V1,19:[1,18],20:19,21:20},{3:5,4:$V0,5:$V1,6:6,7:$V2,8:3,9:$V3,10:4,11:$V4,12:$V5,14:24,16:7,17:8,18:$V6,24:$V7,25:[1,22],26:23},{1:[2,7]},o($V8,[2,14]),{19:[1,25],23:[1,26]},o($Va,[2,17]),{22:[1,27]},o($V8,[2,19]),{23:[1,29],25:[1,28]},o($Vb,[2,21]),o($V8,[2,15]),{3:21,4:$V0,5:$V1,21:30},{3:5,4:$V0,5:$V1,6:6,7:$V2,8:3,9:$V3,10:4,11:$V4,12:$V5,14:31,16:7,17:8,18:$V6,24:$V7},o($V8,[2,20]),{3:5,4:$V0,5:$V1,6:6,7:$V2,8:3,9:$V3,10:4,11:$V4,12:$V5,14:32,16:7,17:8,18:$V6,24:$V7},o($Va,[2,18]),o($Va,[2,16]),o($Vb,[2,22])],\ndefaultActions: {17:[2,7]},\nparseError: function parseError (str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function(match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex () {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin (condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState () {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules () {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState (n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState (condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n  function fail (reason, token) {\n    var lexer = yy.lexer\n    var message = 'Parse error on line ' + yy_.yylineno + ':'\n      + (lexer.showPosition ? '\\n' + lexer.showPosition() + '\\n' : ' ')\n      + reason\n    this.parseError(message, {\n      text: yy_.yytext, token: token, line: yy_.yylineno, loc: yy_.yylloc\n    })\n  }\n\n  function string (token) {\n    yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2)\n    return token\n  }\n\n  // Workaround for a wrong value in yy_.yy_.yylloc. lexer.yy_.yylloc is correct.\n  if (yy.parseError) {\n    yy.parseError.yy = yy.lexer\n  }\n\n  yy.comment = function () {\n    if (!yy.ignoreComments) {\n      fail.call(this, 'Unexpected comment', 'COMMENT')\n    }\n  }\n\n  yy.string = function () {\n    return string('STRING')\n  }\n\n  yy.singleQuotedString = function () {\n    if (yy.allowSingleQuotedStrings) {\n      return string('SINGLEQUOTED_STRING')\n    }\n    fail.call(this, 'Unexpected single-quoted string', 'SINGLEQUOTED_STRING')\n  }\n\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:/* skip whitespace */\nbreak;\ncase 1:yy.comment.call(this)\nbreak;\ncase 2:yy.comment.call(this)\nbreak;\ncase 3:return 7\nbreak;\ncase 4:return yy.string.call(this)\nbreak;\ncase 5:return yy.singleQuotedString.call(this)\nbreak;\ncase 6:return 18\nbreak;\ncase 7:return 19\nbreak;\ncase 8:return 24\nbreak;\ncase 9:return 25\nbreak;\ncase 10:return 23\nbreak;\ncase 11:return 22\nbreak;\ncase 12:return 11\nbreak;\ncase 13:return 12\nbreak;\ncase 14:return 9\nbreak;\ncase 15:return 15\nbreak;\ncase 16:return 'INVALID'\nbreak;\n}\n},\nrules: [/^(?:\\s+)/,/^(?:\\/\\/.*)/,/^(?:[\\/][*][^*]*[*]+([^\\/*][^*]*[*]+)*[\\/])/,/^(?:(-?([0-9]|[1-9][0-9]+))(\\.[0-9]+)?([eE][-+]?[0-9]+)?\\b)/,/^(?:\"(?:\\\\[\\\\\"bfnrt\\/]|\\\\u[a-fA-F0-9]{4}|[^\\\\\\0-\\x09\\x0a-\\x1f\"])*\")/,/^(?:'(?:\\\\[\\\\'bfnrt\\/]|\\\\u[a-fA-F0-9]{4}|[^\\\\\\0-\\x09\\x0a-\\x1f'])*')/,/^(?:\\{)/,/^(?:\\})/,/^(?:\\[)/,/^(?:\\])/,/^(?:,)/,/^(?::)/,/^(?:true\\b)/,/^(?:false\\b)/,/^(?:null\\b)/,/^(?:$)/,/^(?:.)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\nfunction getLineAndColumn (input, offset) {\n  var lines = input\n    .substr(0, offset)\n    .split(/\\r?\\n/)\n  var line = lines.length\n  var column = lines[line - 1].length + 1\n  return {\n    line: line,\n    column: column\n  }\n}\n\nfunction pastInput (input, offset) {\n  var start = Math.max(0, offset - 20)\n  var previous = input.substr(start, offset - start)\n  return (offset > 20 ? '...' : '') + previous.replace(/\\n/g, '')\n}\n\nfunction upcomingInput (input, offset) {\n  var start = Math.max(0, offset - 20)\n  start += offset - start\n  var rest = input.length - start\n  var next = input.substr(start, Math.min(20, rest))\n  return next.replace(/\\n/g, '') + (rest > 20 ? '...' : '')\n}\n\nfunction getPositionContext (input, offset) {\n  var past = pastInput(input, offset)\n  var upcoming = upcomingInput(input, offset)\n  var pointer = new Array(past.length + 1).join('-') + '^'\n  return {\n    exzerpt: past + upcoming,\n    pointer: pointer\n  }\n}\n\nfunction getReason (error) {\n  var message = error.message\n    .replace('JSON.parse: ', '') // SpiderMonkey\n    .replace('JSON Parse error: ', '') // SquirrelFish\n  var firstCharacter = message.charAt(0)\n  if (firstCharacter >= 'a') {\n    message = firstCharacter.toUpperCase() + message.substr(1)\n  }\n  return message\n}\n\nfunction getLocationOnV8 (input, reason) {\n  var match = / in JSON at position (\\d+)$/.exec(reason)\n  if (match) {\n    var offset = +match[1]\n    var location = getLineAndColumn(input, offset)\n    return {\n      offset: offset,\n      line: location.line,\n      column: location.column,\n      reason: reason.substr(0, match.index)\n    }\n  }\n}\n\nfunction checkUnexpectedEndOnV8 (input, reason) {\n  var match = / end of JSON input$/.exec(reason)\n  if (match) {\n    var offset = input.length\n    var location = getLineAndColumn(input, offset)\n    return {\n      offset: offset,\n      line: location.line,\n      column: location.column,\n      reason: reason.substr(0, match.index + 4)\n    }\n  }\n}\n\nfunction getLocationOnSpiderMonkey (input, reason) {\n  var match = / at line (\\d+) column (\\d+) of the JSON data$/.exec(reason)\n  if (match) {\n    var line = +match[1]\n    var column = +match[2]\n    var offset = getOffset(input, line, column) // eslint-disable-line no-undef\n    return {\n      offset: offset,\n      line: line,\n      column: column,\n      reason: reason.substr(0, match.index)\n    }\n  }\n}\n\nfunction getTexts (reason, input, offset, line, column) {\n  var position = getPositionContext(input, offset)\n  var exzerpt = position.exzerpt\n  var message, pointer\n  if (typeof line === 'number') {\n    pointer = position.pointer\n    message = 'Parse error on line ' + line + ', column ' +\n      column + ':\\n' + exzerpt + '\\n' + pointer + '\\n' + reason\n  } else {\n    message = 'Parse error in JSON input:\\n' + exzerpt + '\\n' + reason\n  }\n  return {\n    message: message,\n    exzerpt: exzerpt,\n    pointer: pointer\n  }\n}\n\nfunction improveNativeError (input, error) {\n  var reason = getReason(error)\n  var location = getLocationOnV8(input, reason) ||\n    checkUnexpectedEndOnV8(input, reason) ||\n    getLocationOnSpiderMonkey(input, reason)\n  var offset, line, column\n  if (location) {\n    offset = location.offset\n    line = location.line\n    column = location.column\n    reason = location.reason\n  } else {\n    offset = 0\n  }\n  error.reason = reason\n  var texts = getTexts(reason, input, offset, line, column)\n  error.message = texts.message\n  error.exzerpt = texts.exzerpt\n  if (texts.pointer) {\n    error.pointer = texts.pointer\n    error.location = {\n      start: {\n        column: column,\n        line: line,\n        offset: offset\n      }\n    }\n  }\n  return error\n}\n\nfunction parseNatively (input) { // eslint-disable-line no-unused-vars\n  try {\n    return JSON.parse(input)\n  } catch (error) {\n    throw improveNativeError(input, error)\n  }\n}\n\nfunction needsCustomParser () { // eslint-disable-line no-unused-vars\n  var yy = this.yy\n  return yy.ignoreComments || yy.allowSingleQuotedStrings ||\n    yy.limitedErrorInfo !== true\n}\n\nfunction getOffset (input, line, column) {\n  if (line > 1) {\n    var breaks = /\\r?\\n/g\n    var match\n    while (match = breaks.exec(input)) { // eslint-disable-line no-cond-assign\n      if (--line === 1) {\n        return match.index + column\n      }\n    }\n  }\n  return column - 1\n}\n\nfunction improveCustomError (input, error) {\n  var location = error.hash && error.hash.loc\n  if (location) {\n    var line = location.first_line\n    var column = location.first_column\n    var offset = getOffset(input, line, column)\n    error.location = {\n      start: {\n        line: line,\n        column: column,\n        offset: offset\n      }\n    }\n  }\n  var message = error.message\n  var lines = message.split(/\\r?\\n/)\n  if (lines.length > 1) {\n    error.reason = lines[3]\n    error.exzerpt = lines[2]\n    error.pointer = lines[1]\n  } else {\n    error.reason = message\n    error.exzerpt = input\n      .substr(0, 40)\n      .replace(/\\n/g, '')\n  }\n  return error\n}\n\nfunction parseCustom (parse, input) { // eslint-disable-line no-unused-vars\n  if (this.yy.limitedErrorInfo) {\n    try {\n      return parse.call(this, input)\n    } catch (error) {\n      throw improveCustomError(input, error)\n    }\n  } else {\n    return parse.call(this, input)\n  }\n}\n\n/* globals jsonlint, needsCustomParser, parseCustom, parseNatively */\n\nvar Parser = jsonlint.Parser\n\nfunction ConfigurableParser (options) {\n  Parser.prototype.constructor.call(this)\n  processOptions.call(this, options)\n}\n\nfunction parse (input, options) {\n  var changed = processOptions.call(this, options)\n  try {\n    return needsCustomParser.call(this)\n      ? parseCustom.call(this, Parser.prototype.parse, input)\n      : parseNatively(input)\n  } finally {\n    restoreContext.call(this, changed)\n  }\n}\n\nfunction processOptions (options) {\n  if (options) {\n    var changed = {}\n    if (options.ignoreComments !== undefined) {\n      changed.ignoreComments = this.yy.ignoreComments\n      this.yy.ignoreComments = options.ignoreComments\n    }\n    if (options.allowSingleQuotedStrings !== undefined) {\n      changed.allowSingleQuotedStrings = this.yy.allowSingleQuotedStrings\n      this.yy.allowSingleQuotedStrings = options.allowSingleQuotedStrings\n    }\n    if (options.limitedErrorInfo !== undefined) {\n      changed.limitedErrorInfo = this.yy.limitedErrorInfo\n      this.yy.limitedErrorInfo = options.limitedErrorInfo\n    }\n    return changed\n  }\n}\n\nfunction restoreContext (changed) {\n  if (changed) {\n    var yy = this.yy\n    for (var option in changed) {\n      var value = changed[option]\n      if (value === undefined) {\n        delete yy[option]\n      } else {\n        yy[option] = value\n      }\n    }\n  }\n}\n\nConfigurableParser.prototype = Object.create(Parser.prototype)\nConfigurableParser.prototype.constructor = ConfigurableParser\nConfigurableParser.prototype.parse = parse\nConfigurableParser.prototype.Parser = ConfigurableParser\n\njsonlint = new ConfigurableParser() // eslint-disable-line no-global-assign\n\n  exports.parser = jsonlint;\n  exports.Parser = jsonlint.Parser;\n  exports.parse = jsonlint.parse.bind(jsonlint)\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n}));\n"]}