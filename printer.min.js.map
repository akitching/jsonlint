{"version":3,"sources":["lib/printer.js"],"names":["global","factory","exports","module","define","amd","self","jsonlintPrinter","this","noop","isIdentifierName","value","test","concatenateTokens","tokens","outputString","tokenCount","length","tokenIndex","raw","print","options","Error","indentString","indent","prettyPrint","undefined","pruneComments","stripObjectKeys","foundLineBreak","addedLineBreak","needsLineBreak","addedSpace","needsSpace","indentLevel","scopes","scopeType","isValue","token","tokenType","tokenContent","addIndent","i","addLineBreak","addDelayedSpaceOrLineBreak","addStandaloneComment","tryAddingInlineComment","tryTokenIndex","skipWhitespace","type","indexOf","substr","addLiteral","tokenValue","openScope","push","closeScope","pop","addComma","addColon","Object","defineProperty"],"mappings":"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","file":"printer.js","sourcesContent":["(function (global, factory) {\n  // eslint-disable-next-line no-unused-expressions\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)\n  // eslint-disable-next-line no-undef\n    : typeof define === 'function' && define.amd ? define('jsonlint-printer', ['exports'], factory)\n    // eslint-disable-next-line no-undef\n      : (global = global || self, factory(global.jsonlintPrinter = {}))\n}(this, function (exports) {\n  'use strict'\n\n  function noop () {}\n\n  function isIdentifierName (value) {\n    return /^[a-zA-Z$_][a-zA-Z0-9$_]*$/.test(value)\n  }\n\n  function concatenateTokens (tokens) {\n    var outputString = ''\n    var tokenCount = tokens.length\n    var tokenIndex\n    for (tokenIndex = 0; tokenIndex < tokenCount; ++tokenIndex) {\n      outputString += tokens[tokenIndex].raw\n    }\n    return outputString\n  }\n\n  function print (tokens, options) {\n    if (!(tokens && tokens.length)) {\n      throw new Error('JSON tokens missing.')\n    }\n    // Whitespace and comments are available only as raw token content.\n    if (!(tokens[0] && tokens[0].raw)) {\n      throw new Error('JSON tokens lack raw values.')\n    }\n\n    if (!options) {\n      // If no options, not even an empty object is passed, just concatenate\n      // the raw tokens with neither minification, nor pretty-printing.\n      return concatenateTokens(tokens)\n    }\n\n    var indentString = options.indent\n    // Setting the indent to an empty string enables pretty-printing too.\n    // It will just insert line breaks without any indentation.\n    var prettyPrint = indentString !== undefined\n    var pruneComments = options.pruneComments\n    var stripObjectKeys = options.stripObjectKeys\n\n    var outputString = ''\n    var foundLineBreak, addedLineBreak, needsLineBreak\n    var addedSpace, needsSpace\n    var indentLevel = 0\n    var scopes = []\n    var scopeType\n    var isValue\n    var tokenCount = tokens.length\n    var tokenIndex, token, tokenType, tokenContent\n\n    var addIndent\n    if (prettyPrint && indentString) {\n      addIndent = function () {\n        for (var i = 0; i < indentLevel; ++i) {\n          outputString += indentString\n        }\n      }\n    } else {\n      addIndent = noop\n    }\n\n    var addLineBreak, addDelayedSpaceOrLineBreak\n    if (prettyPrint) {\n      addLineBreak = function () {\n        outputString += '\\n'\n      }\n\n      addDelayedSpaceOrLineBreak = function () {\n        // A line break is more important than a space.\n        if (needsLineBreak) {\n          addLineBreak()\n          addIndent()\n        } else if (needsSpace) {\n          outputString += ' '\n        }\n        needsSpace = needsLineBreak = false\n      }\n    } else {\n      addLineBreak = addDelayedSpaceOrLineBreak = noop\n    }\n\n    var addStandaloneComment, tryAddingInlineComment\n    if (pruneComments) {\n      addStandaloneComment = tryAddingInlineComment = noop\n    } else {\n      if (prettyPrint) {\n        addStandaloneComment = function () {\n          // If a comment is not appended to the end of a line, it will start\n          // on a new line with the current indentation.\n          if (!addedLineBreak && tokenIndex > 0) {\n            addLineBreak()\n            addIndent()\n          }\n          outputString += tokenContent\n          foundLineBreak = false\n          addedLineBreak = false\n          // If a comment is not appended to the end of a line, it will take\n          // the whole line and has to end by a line break.\n          needsLineBreak = true\n        }\n\n        tryAddingInlineComment = function () {\n          // This function is called after printing a non-line-break character.\n          foundLineBreak = false\n          addedLineBreak = false\n          addedSpace = false\n\n          // Start with the character after the just processed one.\n          var tryTokenIndex = tokenIndex + 1\n\n          function skipWhitespace () {\n            var token = tokens[tryTokenIndex]\n            if (token && token.type === 'whitespace') {\n              foundLineBreak = token.raw.indexOf('\\n') >= 0\n              token = tokens[++tryTokenIndex]\n            }\n            return token\n          }\n\n          var token = skipWhitespace()\n          if (token && token.type === 'comment') {\n            if (foundLineBreak || needsLineBreak) {\n              // If the previous non-whitespace token was ended by a line\n              // break, retain it. Print the comment after the line break too.\n              if (!addedLineBreak) {\n                addLineBreak()\n                addIndent()\n              }\n            } else {\n              // If the previous non-whitespace token was not ended by a line\n              // break, ensure that the comment is separated from it.\n              if (!addedSpace) {\n                outputString += ' '\n              }\n            }\n            outputString += token.raw\n            // Set the current token to the just processed comment.\n            tokenIndex = tryTokenIndex++\n            // Check the whitespace after the comment to give a hint\n            // about the next whitespace to the further processing.\n            skipWhitespace()\n            if (foundLineBreak) {\n              needsSpace = false\n              needsLineBreak = true\n            } else {\n              needsSpace = true\n              needsLineBreak = false\n            }\n          }\n        }\n      } else {\n        // If all whitespace is omitted, convert single-line comments\n        // to multi-line ones, which include a comment-closing token.\n        addStandaloneComment = function () {\n          if (tokenContent[1] === '/') {\n            outputString += '/*'\n            outputString += tokenContent.substr(2, tokenContent.length - 2)\n            outputString += ' */'\n          } else {\n            outputString += tokenContent\n          }\n        }\n\n        tryAddingInlineComment = noop\n      }\n    }\n\n    function addLiteral () {\n      addDelayedSpaceOrLineBreak()\n      var tokenValue = token.value\n      if (stripObjectKeys && scopeType === '{' && !isValue &&\n          isIdentifierName(tokenValue)) {\n        outputString += tokenValue\n      } else {\n        outputString += tokenContent\n      }\n      tryAddingInlineComment()\n    }\n\n    function openScope () {\n      addDelayedSpaceOrLineBreak()\n      scopes.push(scopeType)\n      scopeType = tokenContent\n      isValue = scopeType === '['\n      outputString += tokenContent\n      tryAddingInlineComment()\n      ++indentLevel\n      needsLineBreak = true\n    }\n\n    function closeScope () {\n      scopeType = scopes.pop()\n      addLineBreak()\n      --indentLevel\n      addIndent()\n      needsSpace = needsLineBreak = false\n      outputString += tokenContent\n      tryAddingInlineComment()\n    }\n\n    function addComma () {\n      addDelayedSpaceOrLineBreak()\n      outputString += ','\n      tryAddingInlineComment()\n      addLineBreak()\n      addIndent()\n      addedLineBreak = true\n      needsLineBreak = false\n      isValue = scopeType === '['\n    }\n\n    function addColon () {\n      addDelayedSpaceOrLineBreak()\n      outputString += ':'\n      needsSpace = true\n      tryAddingInlineComment()\n      isValue = true\n    }\n\n    for (tokenIndex = 0; tokenIndex < tokenCount; ++tokenIndex) {\n      token = tokens[tokenIndex]\n      tokenType = token.type\n      tokenContent = token.raw\n      switch (tokenType) {\n        case 'literal':\n          addLiteral()\n          break\n        case 'comment':\n          addStandaloneComment()\n          break\n        case 'symbol':\n          switch (tokenContent) {\n            case '{':\n            case '[':\n              openScope()\n              break\n            case '}':\n            case ']':\n              closeScope()\n              break\n            case ',':\n              addComma()\n              break\n            case ':':\n              addColon()\n          }\n          break\n        default: // whitespace\n          foundLineBreak = tokenContent.indexOf('\\n') >= 0\n      }\n    }\n\n    return outputString\n  }\n\n  exports.print = print\n\n  Object.defineProperty(exports, '__esModule', { value: true })\n}))\n"]}