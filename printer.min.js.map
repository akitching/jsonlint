{"version":3,"sources":["lib/printer.js"],"names":["global","factory","exports","module","define","amd","self","jsonlintPrinter","this","noop","isIdentifierName","value","test","concatenateTokens","tokens","outputString","tokenCount","length","tokenIndex","raw","print","options","Error","indentString","indent","Array","join","prettyPrint","undefined","pruneComments","stripObjectKeys","enforceDoubleQuotes","enforceSingleQuotes","foundLineBreak","addedLineBreak","needsLineBreak","addedSpace","needsSpace","indentLevel","scopes","scopeType","isValue","token","tokenType","tokenContent","addIndent","i","addLineBreak","addDelayedSpaceOrLineBreak","addStandaloneComment","tryAddingInlineComment","tryTokenIndex","skipWhitespace","type","indexOf","substr","addLiteral","tokenValue","JSON","stringify","replace","openScope","push","closeScope","pop","addComma","addColon","Object","defineProperty"],"mappings":"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","file":"printer.js","sourcesContent":["(function (global, factory) {\n  // eslint-disable-next-line no-unused-expressions\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)\n  // eslint-disable-next-line no-undef\n    : typeof define === 'function' && define.amd ? define('jsonlint-printer', ['exports'], factory)\n    // eslint-disable-next-line no-undef\n      : (global = global || self, factory(global.jsonlintPrinter = {}))\n}(this, function (exports) {\n  'use strict'\n\n  function noop () {}\n\n  function isIdentifierName (value) {\n    return /^[a-zA-Z$_][a-zA-Z0-9$_]*$/.test(value)\n  }\n\n  function concatenateTokens (tokens) {\n    var outputString = ''\n    var tokenCount = tokens.length\n    var tokenIndex\n    for (tokenIndex = 0; tokenIndex < tokenCount; ++tokenIndex) {\n      outputString += tokens[tokenIndex].raw\n    }\n    return outputString\n  }\n\n  function print (tokens, options) {\n    if (!(tokens && tokens.length)) {\n      throw new Error('JSON tokens missing.')\n    }\n    // Whitespace and comments are available only as raw token content.\n    if (!(tokens[0] && tokens[0].raw)) {\n      throw new Error('JSON tokens lack raw values.')\n    }\n\n    if (!options) {\n      // If no options, not even an empty object is passed, just concatenate\n      // the raw tokens with neither minification, nor pretty-printing.\n      return concatenateTokens(tokens)\n    }\n\n    var indentString = options.indent\n    if (typeof indentString === 'number') {\n      indentString = new Array(indentString + 1).join(' ')\n    }\n    // Setting the indent to an empty string enables pretty-printing too.\n    // It will just insert line breaks without any indentation.\n    var prettyPrint = indentString !== undefined\n    var pruneComments = options.pruneComments\n    var stripObjectKeys = options.stripObjectKeys\n    var enforceDoubleQuotes = options.enforceDoubleQuotes\n    var enforceSingleQuotes = options.enforceSingleQuotes\n\n    var outputString = ''\n    var foundLineBreak, addedLineBreak, needsLineBreak\n    var addedSpace, needsSpace\n    var indentLevel = 0\n    var scopes = []\n    var scopeType\n    var isValue\n    var tokenCount = tokens.length\n    var tokenIndex, token, tokenType, tokenContent\n\n    var addIndent\n    if (prettyPrint && indentString) {\n      addIndent = function () {\n        for (var i = 0; i < indentLevel; ++i) {\n          outputString += indentString\n        }\n      }\n    } else {\n      addIndent = noop\n    }\n\n    var addLineBreak, addDelayedSpaceOrLineBreak\n    if (prettyPrint) {\n      addLineBreak = function () {\n        outputString += '\\n'\n      }\n\n      addDelayedSpaceOrLineBreak = function () {\n        // A line break is more important than a space.\n        if (needsLineBreak) {\n          addLineBreak()\n          addIndent()\n        } else if (needsSpace) {\n          outputString += ' '\n        }\n        needsSpace = needsLineBreak = false\n      }\n    } else {\n      addLineBreak = addDelayedSpaceOrLineBreak = noop\n    }\n\n    var addStandaloneComment, tryAddingInlineComment\n    if (pruneComments) {\n      addStandaloneComment = tryAddingInlineComment = noop\n    } else {\n      if (prettyPrint) {\n        addStandaloneComment = function () {\n          // If a comment is not appended to the end of a line, it will start\n          // on a new line with the current indentation.\n          if (!addedLineBreak && tokenIndex > 0) {\n            addLineBreak()\n            addIndent()\n          }\n          outputString += tokenContent\n          foundLineBreak = false\n          addedLineBreak = false\n          // If a comment is not appended to the end of a line, it will take\n          // the whole line and has to end by a line break.\n          needsLineBreak = true\n        }\n\n        tryAddingInlineComment = function () {\n          // This function is called after printing a non-line-break character.\n          foundLineBreak = false\n          addedLineBreak = false\n          addedSpace = false\n\n          // Start with the character after the just processed one.\n          var tryTokenIndex = tokenIndex + 1\n\n          function skipWhitespace () {\n            var token = tokens[tryTokenIndex]\n            if (token && token.type === 'whitespace') {\n              foundLineBreak = token.raw.indexOf('\\n') >= 0\n              token = tokens[++tryTokenIndex]\n            }\n            return token\n          }\n\n          var token = skipWhitespace()\n          // If line break followed the previous token, leave the comment\n          // to be handled by the next usual token processing.\n          if (!foundLineBreak && token && token.type === 'comment') {\n            if (needsLineBreak) {\n              // If the previous non-whitespace token was ended by a line\n              // break, retain it. Print the comment after the line break too.\n              if (!addedLineBreak) {\n                addLineBreak()\n                addIndent()\n              }\n            } else {\n              // If the previous non-whitespace token was not ended by a line\n              // break, ensure that the comment is separated from it.\n              if (!addedSpace) {\n                outputString += ' '\n              }\n            }\n            outputString += token.raw\n            // Set the current token to the just processed comment.\n            tokenIndex = tryTokenIndex++\n            // Check the whitespace after the comment to give a hint\n            // about the next whitespace to the further processing.\n            skipWhitespace()\n            if (foundLineBreak) {\n              needsSpace = false\n              needsLineBreak = true\n            } else {\n              needsSpace = true\n              needsLineBreak = false\n            }\n          }\n        }\n      } else {\n        // If all whitespace is omitted, convert single-line comments\n        // to multi-line ones, which include a comment-closing token.\n        addStandaloneComment = function () {\n          if (tokenContent[1] === '/') {\n            outputString += '/*'\n            outputString += tokenContent.substr(2, tokenContent.length - 2)\n            outputString += ' */'\n          } else {\n            outputString += tokenContent\n          }\n        }\n\n        tryAddingInlineComment = noop\n      }\n    }\n\n    function addLiteral () {\n      addDelayedSpaceOrLineBreak()\n      var tokenValue = token.value\n      if (stripObjectKeys && scopeType === '{' && !isValue &&\n          isIdentifierName(tokenValue)) {\n        outputString += tokenValue\n      } else if (typeof tokenValue === 'string') {\n        if (enforceDoubleQuotes && tokenContent[0] !== '\"') {\n          outputString += JSON.stringify(tokenValue)\n        } else if (enforceSingleQuotes && tokenContent[0] !== '\\'') {\n          outputString += '\\'' + tokenValue.replace(/'/g, '\\\\\\'') + '\\''\n        } else {\n          outputString += tokenContent\n        }\n      } else {\n        outputString += tokenContent\n      }\n      tryAddingInlineComment()\n    }\n\n    function openScope () {\n      addDelayedSpaceOrLineBreak()\n      scopes.push(scopeType)\n      scopeType = tokenContent\n      isValue = scopeType === '['\n      outputString += tokenContent\n      tryAddingInlineComment()\n      ++indentLevel\n      needsLineBreak = true\n    }\n\n    function closeScope () {\n      scopeType = scopes.pop()\n      addLineBreak()\n      --indentLevel\n      addIndent()\n      needsSpace = needsLineBreak = false\n      outputString += tokenContent\n      tryAddingInlineComment()\n    }\n\n    function addComma () {\n      addDelayedSpaceOrLineBreak()\n      outputString += ','\n      tryAddingInlineComment()\n      addLineBreak()\n      addIndent()\n      addedLineBreak = true\n      needsLineBreak = false\n      isValue = scopeType === '['\n    }\n\n    function addColon () {\n      addDelayedSpaceOrLineBreak()\n      outputString += ':'\n      needsSpace = true\n      tryAddingInlineComment()\n      isValue = true\n    }\n\n    for (tokenIndex = 0; tokenIndex < tokenCount; ++tokenIndex) {\n      token = tokens[tokenIndex]\n      tokenType = token.type\n      tokenContent = token.raw\n      switch (tokenType) {\n        case 'literal':\n          addLiteral()\n          break\n        case 'comment':\n          addStandaloneComment()\n          break\n        case 'symbol':\n          switch (tokenContent) {\n            case '{':\n            case '[':\n              openScope()\n              break\n            case '}':\n            case ']':\n              closeScope()\n              break\n            case ',':\n              addComma()\n              break\n            case ':':\n              addColon()\n          }\n          break\n        default: // whitespace\n          foundLineBreak = tokenContent.indexOf('\\n') >= 0\n      }\n    }\n\n    return outputString\n  }\n\n  exports.print = print\n\n  Object.defineProperty(exports, '__esModule', { value: true })\n}))\n"]}